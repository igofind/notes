# 分区研究与问题整理

数据库版本为 MySQL 5.7



## 表引擎

### InnoDB

### MyISAM

### memory(heap)

### archive



## 分区类型

### 范围分区

**RANGE Partitioning** 

按指定字段a将一个表切成若干段，每一段的数据的字段a的值都在某个区间内。类似于编程语言中的if ... else if ... else if ...

**举例** 

```mysql
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (store_id) (
    PARTITION p0 VALUES LESS THAN (6),
    PARTITION p1 VALUES LESS THAN (11),
    PARTITION p2 VALUES LESS THAN (16),
    PARTITION p3 VALUES LESS THAN (21)
);
```

- 以id字段分割为四个区0~5，6~10，11~15，16~20

- 所有数据的id须小于21，否则会报错，使用`MAXVALUE`避免出错误

  ```mysql
  PARTITION p3 VALUES LESS THAN MAXVALUE
  ```

- SELECT * FROM test.employees PARTITION(p0) 可查询第一个分区的数据

范围分区可接受能通过`LESS THAN`语句对比的语法

```mysql
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY RANGE ( YEAR(separated) ) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1996),
    PARTITION p2 VALUES LESS THAN (2001),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

- `PARTITION BY RANGE ( YEAR(separated) ) ` 中可以使用一些函数
  - 关于时间戳的函数，只能用`UNIX_TIMESTAMP(report_updated)`

**使用场景** 

当在下列场景时，范围分区特别实用。

- 需要或想删除“旧”数据。

  ```mysql
  -- 可以删除整个p0分区的数据，比使用DELETE语句更有效率
  ALTER TABLE employees DROP PARTITION p0
  ```

- 想要使用包含日期或时间值的列，或者包含来自其他系列的值。

  - [ ] 有些含糊，需细究

- 经常运行直接依赖于用于分区表的列的查询。



### 列表分区

LIST Partitioning

- 与`RANGER`分区很类似，也是分为区间，但区间的范围是使用`in`枚举出来的，`in`的使用就像是`where`条件中的`in`

- 没有类似范围分区中的`MAXVALUE`的语法。如果插入数据不在任意一个区间中，则会报错。为了避免报错，可以使用`Ignore`

  ```mysql
  -- 如果插入的值不在任意一个区间内，就会忽略这条数据，并不会报错
  INSERT IGNORE INTO h2 VALUES (2, 5), (6, 10), (7, 5), (3, 1), (1, 9);
  ```



### 列分区

COLUMNS Partitioning 

- 是范围分区与列表分区的变种


- 允许在分键中使用多个列
- 允许使用非整型列进行分区，所有支持列分区的类型如下：
  - 所有整型类型：`TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT (INTEGER)` and `BIGINT`
    - `DECIMAL` or `FLOAT`类型不支持列分区
  - 部分日期类型：`DATE`和`DATETIME`。
    - 其他与日期和时间相关的类型不支持。
  - 部分字符类型： `CHAR`, `VARCHAR`, `BINARY`, and `VARBINARY`。
    - `TEXT`and`BLOB`则不支持。

#### 范围列分区

- 不支持表达式，只接受列名
- 接受一个或多个列名
- 不只接受整型列（参考上文）

**语法**

```mysql
CREATE TABLE table_name
PARTITIONED BY RANGE COLUMNS(column_list) (
    PARTITION partition_name VALUES LESS THAN (value_list)[,
    PARTITION partition_name VALUES LESS THAN (value_list)][,
    ...]
)

column_list:
    column_name[, column_name][, ...]

value_list:
    value[, value][, ...]
```

**举例**

```mysql
mysql> CREATE TABLE rcx (
    ->     a INT,
    ->     b INT,
    ->     c CHAR(3),
    ->     d INT
    -> )
    -> PARTITION BY RANGE COLUMNS(a,d,c) (
    ->     PARTITION p0 VALUES LESS THAN (5,10,'ggg'),
    ->     PARTITION p1 VALUES LESS THAN (10,20,'mmm'),
    ->     PARTITION p2 VALUES LESS THAN (15,30,'sss'),
    ->     PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
    -> );
```

- 使用范围分区的语法

- 可以使用MAXVALUE

  - 可以出现在不同 `LESS THAN `语句中同一列的位置上
  - 应该出现在最后的`LESS THEN`语句中
  - 在多于一个分区的声明中，`MAXVALUE`	不能出现在第一`LESS THAN`语句中

- 分区的确定是根据列值元组的比较来决定的

  ```mysql
  -- 分区表
  CREATE TABLE rc1 (
      a INT,
      b INT
  )
  PARTITION BY RANGE COLUMNS(a, b) (
      PARTITION p0 VALUES LESS THAN (5, 12),
      PARTITION p3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
  );
  -- 数据
  INSERT INTO rc1 VALUES (5,10), (5,11), (5,12);

  -- 分区过程
  SELECT (5,10) < (5,12), (5,11) < (5,12), (5,12) < (5,12);
  -- 或 SELECT ROW(5,10) < ROW(5,12), ROW(5,11) < ROW(5,12), ROW(5,12) < ROW(5,12);
  +-----------------+-----------------+-----------------+
  | (5,10) < (5,12) | (5,11) < (5,12) | (5,12) < (5,12) |
  +-----------------+-----------------+-----------------+
  |               1 |               1 |               0 |
  +-----------------+-----------------+-----------------+

  -- 结果
  +--------------+----------------+------------+
  | TABLE_SCHEMA | PARTITION_NAME | TABLE_ROWS |
  +--------------+----------------+------------+
  | p            | p0             |          2 |
  | p            | p1             |          1 |
  +--------------+----------------+------------+
  ```

- 只有一个列的列分区表等价于范围分区

- 一个列的分区界限值可以在多个分区中出现，

  ```mysql
  CREATE TABLE rc3 (
      a INT,
      b INT
  )
  PARTITION BY RANGE COLUMNS(a,b) (
      PARTITION p0 VALUES LESS THAN (0,10),
      PARTITION p1 VALUES LESS THAN (10,20),
      PARTITION p2 VALUES LESS THAN (10,30),
      PARTITION p3 VALUES LESS THAN (10,35),
      PARTITION p4 VALUES LESS THAN (20,40),
      PARTITION p5 VALUES LESS THAN (MAXVALUE,MAXVALUE)
   );	
  ```


- 分区声明中元组内的值必须是**严格递增**的否则会报错。
- ​

#### 列表列分区



### HASH分区

HASH Partitioning

### KEY分区

KEY Partitioning

### 子分区

Subpartitioning



## 使用建议

如果要使用时间间隔来进行分区，有两种做法：

- 可在分区语法中将列值转为整型值。可用的函数有`YEAR()` 、`UNIX_TIMESTAMP()`
  - `TIMESTAMP` 类型的列只能使用`UNIX_TIMESTAMP`
- 使用Date、DateTime类型的列，可以直接在`RANGE COLUMNS`分区中使用



## 问题

- [ ] MySQL分区如何处理NULL - How MySQL Partitioning Handles NULL


- [ ] 水平分区

      - [ ] MySQL 5.7不支持垂直分区

- [ ] 表引擎：MyISAM

- [ ] 分区个数

      - [ ] 能不能动态添加

- [ ] 索引与数据目录是否分开

- [ ] All columns used in the table's partitioning expression must be part of every unique key that the table may have, including any primary key. This means that a table such as this one, created by the following SQL statement, cannot be partitioned:

          CREATE TABLE tnp (
          id INT NOT NULL AUTO_INCREMENT,
          ref BIGINT NOT NULL,
          name VARCHAR(255),
          PRIMARY KEY pk (id),
          UNIQUE KEY uk (name)
          );
      Because the keys pk and uk have no columns in common, there are no columns available for use in a partitioning expression. 

- [ ] MAX_ROWS MIN_ROWS 最大行数和最小行数配置

- [ ] 分区的好处

      - [ ] 分区可以在一个表中存储比单个磁盘或文件系统分区上的数据更多的数据

      - [ ] 失去其有用性的数据通常可以通过删除仅包含该数据的分区（或分区）从分区表中轻松删除。相反，添加新数据的过程在某些情况下可以通过添加一个或多个新的分区来专门存储该数据而大大方便。

      - [ ] 由于满足给定WHERE子句的数据只能存储在一个或多个分区上，因此可自动排除搜索中剩余的分区，因此可以大大优化某些查询。

            由于在创建分区表后可以更改分区，因此您可以重新组织数据以增强在首次设置分区方案时可能不经常使用的频繁查询。这种排除不匹配的分区（以及它们包含的任何行）的功能通常称为分区修剪。

            MySQL 5.7支持在查询语句、数据库修改语句中直接指定分区号。




## 常用

查看表分区语句

```mysql
-- 可以查询该表的建表语句
SHOW CREATE TABLE test.employees;
```

查看表分区信息

```mysql
SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'r1';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          3 |
+----------------+------------+
```

给没有分区的表添加分区

```mysql
ALTER TABLE employees PARTITION BY RANGE COLUMNS (lname)  (
    PARTITION p0 VALUES LESS THAN ('g'),
    PARTITION p1 VALUES LESS THAN ('m'),
    PARTITION p2 VALUES LESS THAN ('t'),
    PARTITION p3 VALUES LESS THAN (MAXVALUE)
);
```

