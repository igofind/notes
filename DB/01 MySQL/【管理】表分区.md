# 分区研究与问题整理

数据库版本为 MySQL 5.7



## 表引擎

### InnoDB

### MyISAM

### memory(heap)

### archive



## 分区类型

### 范围分区

**RANGE Partitioning** 

按指定字段a将一个表切成若干段，每一段的数据的字段a的值都在某个区间内。类似于编程语言中的if ... else if ... else if ...

**举例** 

```mysql
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
)
PARTITION BY RANGE (store_id) (
    PARTITION p0 VALUES LESS THAN (6),
    PARTITION p1 VALUES LESS THAN (11),
    PARTITION p2 VALUES LESS THAN (16),
    PARTITION p3 VALUES LESS THAN (21)
);
```

- 以id字段分割为四个区0~5，6~10，11~15，16~20

- 所有数据的id须小于21，否则会报错，使用`MAXVALUE`避免出错误

  ```mysql
  PARTITION p3 VALUES LESS THAN MAXVALUE
  ```

- SELECT * FROM test.employees PARTITION(p0) 可查询第一个分区的数据

范围分区可接受能通过`LESS THAN`语句对比的语法

```mysql
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY RANGE ( YEAR(separated) ) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1996),
    PARTITION p2 VALUES LESS THAN (2001),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

- `PARTITION BY RANGE ( YEAR(separated) ) ` 中可以使用一些函数
  - 关于时间戳的函数，只能用`UNIX_TIMESTAMP(report_updated)`

**使用场景** 

当在下列场景时，范围分区特别实用。

- 需要或想删除“旧”数据。

  ```mysql
  -- 可以删除整个p0分区的数据，比使用DELETE语句更有效率
  ALTER TABLE employees DROP PARTITION p0
  ```

- 想要使用包含日期或时间值的列，或者包含来自其他系列的值。

  - [ ] 有些含糊，需细究

- 经常运行直接依赖于用于分区表的列的查询。



### 列表分区

LIST Partitioning

### 列分区

COLUMNS Partitioning

### HASH分区

HASH Partitioning

### KEY分区

KEY Partitioning

### 子分区

Subpartitioning



## 使用建议

如果要使用时间间隔来进行分区，有两种做法：

- 可在分区语法中将列值转为整型值。可用的函数有`YEAR()` 、`UNIX_TIMESTAMP()`
  - `TIMESTAMP` 类型的列只能使用`UNIX_TIMESTAMP`
- 使用Date、DateTime类型的列，可以直接在`RANGE COLUMNS`分区中使用



## 问题

- [ ] MySQL分区如何处理NULL - How MySQL Partitioning Handles NULL


- [ ] 水平分区

      - [ ] MySQL 5.7不支持垂直分区

- [ ] 表引擎：MyISAM

- [ ] 分区个数

      - [ ] 能不能动态添加

- [ ] 索引与数据目录是否分开

- [ ] All columns used in the table's partitioning expression must be part of every unique key that the table may have, including any primary key. This means that a table such as this one, created by the following SQL statement, cannot be partitioned:

          CREATE TABLE tnp (
          id INT NOT NULL AUTO_INCREMENT,
          ref BIGINT NOT NULL,
          name VARCHAR(255),
          PRIMARY KEY pk (id),
          UNIQUE KEY uk (name)
          );
      Because the keys pk and uk have no columns in common, there are no columns available for use in a partitioning expression. 

- [ ] MAX_ROWS MIN_ROWS 最大行数和最小行数配置

- [ ] 分区的好处

      - [ ] 分区可以在一个表中存储比单个磁盘或文件系统分区上的数据更多的数据

      - [ ] 失去其有用性的数据通常可以通过删除仅包含该数据的分区（或分区）从分区表中轻松删除。相反，添加新数据的过程在某些情况下可以通过添加一个或多个新的分区来专门存储该数据而大大方便。

      - [ ] 由于满足给定WHERE子句的数据只能存储在一个或多个分区上，因此可自动排除搜索中剩余的分区，因此可以大大优化某些查询。

            由于在创建分区表后可以更改分区，因此您可以重新组织数据以增强在首次设置分区方案时可能不经常使用的频繁查询。这种排除不匹配的分区（以及它们包含的任何行）的功能通常称为分区修剪。

            MySQL 5.7支持在查询语句、数据库修改语句中直接指定分区号。


- [ ] ​